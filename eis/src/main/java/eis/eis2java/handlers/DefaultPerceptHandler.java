package eis.eis2java.handlers;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import eis.PerceptUpdate;
import eis.eis2java.annotation.AsPercept;
import eis.eis2java.translation.Filter;
import eis.eis2java.util.EIS2JavaUtil;
import eis.exceptions.EntityException;
import eis.exceptions.PerceiveException;

/**
 * Default {@link PerceptHandler} for EIS2Java. When called the
 * DefaultPercepthandler will call all percept methods on the agent and return
 * and translate their results.
 */
public final class DefaultPerceptHandler extends AbstractPerceptHandler {
	/** Collection of methods on the entity (that were annotated with @Percept) */
	protected final Collection<Method> perceptMethods;

	public DefaultPerceptHandler(final Object entity) throws EntityException {
		super(entity);
		this.perceptMethods = EIS2JavaUtil.processPerceptAnnotations(entity.getClass());
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see nl.tudelft.goal.EIS2Java.environment.PerceptHandler#getAllPercepts(java
	 * .lang.Object)
	 */
	@Override
	public PerceptUpdate getPercepts() throws PerceiveException {
		final PerceptUpdate percepts = new PerceptUpdate();
		for (final Method method : this.perceptMethods) {
			percepts.merge(getPercepts(method));
		}

		return percepts;
	}

	/**
	 * Creates new percepts by calling the given method on the entity.
	 *
	 * @param entity the entity to get the percept from.
	 * @param method the method to invoke on the entity which must be annotated with
	 *               {@link AsPercept}.
	 * @return The percepts that were generated by invoking the method on the
	 *         entity.
	 * @throws PerceiveException If the percepts couldn't be retrieved.
	 */
	private PerceptUpdate getPercepts(final Method method) throws PerceiveException {
		// list of new objects for the percepts
		List<Object> perceptObjects = new ArrayList<>(0);

		// Optimization, don't call methods for once percepts if they have been
		// called before.
		final AsPercept annotation = method.getAnnotation(AsPercept.class);
		final Filter.Type filter = annotation.filter();
		if (filter != Filter.Type.ONCE || this.previousPercepts.get(method) == null) {
			perceptObjects = getPerceptObjects(method);
		}

		return translatePercepts(method, perceptObjects);
	}

	/**
	 * Get the percept objects for given percept name, using method. May return an
	 * empty list.
	 *
	 * @param method
	 * @param entity
	 * @param perceptName
	 * @return percept objects for given percept name, using method. May return an
	 *         empty list
	 * @throws PerceiveException
	 */
	private List<Object> getPerceptObjects(final Method method) throws PerceiveException {
		final AsPercept annotation = method.getAnnotation(AsPercept.class);
		final String perceptName = annotation.name();

		Object returnValue;
		try {
			returnValue = method.invoke(this.entity);
		} catch (final IllegalArgumentException e) {
			throw new PerceiveException("Unable to perceive " + perceptName, e);
		} catch (final IllegalAccessException e) {
			throw new PerceiveException("Unable to perceive " + perceptName, e);
		} catch (final InvocationTargetException e) {
			throw new PerceiveException("Unable to perceive " + perceptName, e);
		}

		return unpackPerceptObject(method, returnValue);
	}
}
